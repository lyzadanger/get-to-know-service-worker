<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Fun with Service Worker</h1>
					<h3>Or, At Least: Some Things About It</h3>
          <h4>Lyza Danger Gardner, <a href="https://twitter.com/lyzadanger">@lyzadanger</a></h4>
				</section>

				<section>
          <section>
            <h2>The Hell?</h2>
          </section>

          <section data-markdown>
            <script type="text/template">
              A _service worker_ is a script
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              A _service worker_ is a script that acts as a _proxy_
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              A _service worker_ is a script that acts as a _proxy_ between your _client application_
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              A _service worker_ is a script that acts as a _proxy_ between your _client application_ and the _network_
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              A _service worker_ stands between your browser's application code and _requests_
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              A _service worker_ stands between your browser's application code and _requests_, allowing you to _respond_ to requests in different ways, not just relying on the browser's default behavior
            </script>
          </section>

				</section>

        <section>
          <section>
            <h2>OK, but Why?</h2>
          </section>

          <section>
            <h3>Things You Can Do</h3>

            <ul>
              <li>Enhance online performance</li>
              <li>Provide an offline experience</li>
              <li>A whole bunch of other things... <small>(which we're not talking about in-depth today)</small></li>
            </ul>
          </section>

          <section>
            <h3>Enhancing Online Performance</h3>
            <h4>Uh huh...OK...how?</h4>

            <p>We can create a <em>network strategy</em> to optimize a balance between cached content and "fresh" content from the network.</p>
          </section>

          <section>
            <h3>Provide an Offline Experience</h3>
            <h4>Well, This is Very Vague</h4>

            <p>You can <em>explicitly</em> define exactly what happens when a user tries to access your site or app without a network connection.</p>

          </section>

          <section>
            <h3>Combine For Maximum Neat-o</h3>

            <p>Combining <em>network optimization</em> with an <em>offline experience</em> is a one-two punch that you can do <strong>right now*</strong>.</p>

            <p><small>* Well, in some browsers**. Ahem, we'll come back to that.</small></p>

            <p><small>** In the browser you likely use, if you're a dev.</small></p>

          </section>
        </section>

        <section>
          <h2>Building a Thing</h2>
          <p>Let's say you have a content-heavy site, which contains:</p>
          <ul>
            <li class="fragment">Blog posts or other HTML content that changes frequently and is the most important thing on the site.</li>
            <li class="fragment">Supporting assets—images, CSS, JavaScript—that are fairly static.</li>
          </ul>
        </section>

        <section>

          <section>
            <h3>What if you could choose how requests are handled?</h3>
            <ul>
              <li class="fragment">If a request is made for (HTML) content, we always want the freshest, right?</li>
              <li class="fragment">If a request is made for an image, CSS or JavaScript, how about retrieving a cached copy so we don't have to suffer the overhead of a network request?</li>
            </ul>
          </section>

          <section>
            <h3>Enhancing Online Performance with a Network Strategy</h3>
            <p>We can implement a <em>network strategy</em> with our service worker for handling requests (fetches):</p>
            <ul>
              <li class="fragment"><strong>Network-first</strong> for HTML content</li>
              <li class="fragment"><strong>Cache-first</strong> for static assets</li>
            </ul>
          </section>

          <section>
            <h3>Network-First</h3>

            <ol>
              <li class="fragment">Request the resource from the network</li>
              <li class="fragment">If the network fetch fails, try retrieving a copy from cache</li>
            </ol>
          </section>

          <section>
            <h3>Cache-First</h3>

            <ol>
              <li class="fragment">Try retrieving a copy of the asset from cache</li>
              <li class="fragment">If the asset is not available in cache, try getting it from the network</li>
            </ol>
          </section>

          <section>
            <h3>Network Strategy with Service Worker</h3>
            <p>To implement a network strategy with a service worker:</p>

            <ul>
              <li class="fragment">Listen for <em>fetch</em> events</li>
              <li class="fragment">Respond with the right thing</li>
            </ul>

            <p class="fragment">To do this, we need to understand the life and times of a service worker...</p>
          </section>

        </section>

        <section>

          <section>
            <h2>The Lifestyle of a Service Worker: Registering</h2>
            <p>First off, your app or site needs to "connect itself up" to a service worker. It needs to say, hey, I want this service worker to control me.</p>
            <ul>
              <li class="fragment">A service worker gets <em>registered</em> against a <em>scope</em>.</li>
              <li class="fragment">Your application's JavaScript code does the registering.</li>
            </ul>
          </section>

          <section>
            <h3>Registering a Service Worker</h3>
            <pre><code class="hljs">
navigator.serviceWorker.register('/serviceWorker.js', {
  scope: '/blog'
});
            </code></pre>
            <p>This code hooks up:
            <ul>
              <li class="fragment">the <em>/serviceWorker.js</em> script...</li>
              <li class="fragment">to control the <em>/blog</em> scope...</li>
              <li class="fragment">Once registered, the service worker will have control over any page served under <em>/blog</em> from your site's origin.</li>
            </ul>
          </section>

          <section>
            <h3>"Control" Meaning...</h3>
            <p>The service worker will be able to <em>listen</em> for relevant events and respond to them.</p>
          </section>

          <section>
            <h3>Registering a Service Worker...</h3>

            <ul>
              <li class="fragment">...is the job of external scripts on your site</li>
              <li class="fragment">...causes the browser to "hang on" to that service worker until it sees that it has changed</li>
            </ul>
          </section>

          <section>
            <h3>Registration Cycle</h3>
            <p>When a browser sees that there is a new service worker to register, it:</p>
            <ul>
              <li class="fragment">Installs it: triggering the <em>install</em> event</li>
              <li class="fragment">Activates it: triggering the <em>activate</em> event</li>
            </ul>
          </section>

          <section>
            <h3>Install Phase</h3>

            <p>The <em>install</em> phase of a service worker is the time to <em>pre-cache</em> assets you know you want to have available offline later.</p>
          </section>

          <section>
            <h3>Activate Phase</h3>

            <p>The <em>activate</em> phase gives you a chance to clean up after previous versions of a service worker. It doesn't seem too useful when considering installing a brand-new service worker, but, trust me, it'll be useful to us soon.</p>
          </section>

        </section>

        <!-- SECTION --->

        <section>

          <section>
            <h2>Lifestyle of a Service Worker: Fetches</h2>
            <p>Once a service worker has been installed and activated, it can listen for any <em>fetch</em> events triggered by the browser within its scope.</p>
            <p class="fragment">That is, any time the browser wants to fetch an asset that is within the path defined by <em>scope</em>, the registered service worker can hear all about it.</p>
          </section>

          <section>
            <h3>Responding to Fetches</h3>
            <p>A registered service worker can listen to fetch events and:</p>
            <ul>
              <li class="fragment">Respond with something from the network</li>
              <li class="fragment">Respond with something from cache</li>
              <li class="fragment">Respond with something else entirely</li>
              <li class="fragment">Do nothing and let the browser handle it in a default way</li>
            </ul>

            <p class="fragment">Basically, a service worker gets to <em>decide</em> how to fulfill requests from the browser, if it so chooses.</p>
          </section>

        </section>

        <!-- SECTION -->

        <section>

          <section>
            <h2>Structuring the Service Worker</h2><pre><code class="hljs">
    self.addEventListener('install', () => {
      // Pre-cache assets for offline use later
    });

    self.addEventListener('activate', () => {
      // Clean up after old versions of myself
    });

    self.addEventListeners('fetch', event => {
      // Respond to this fetch in a useful way
    });
  </code></pre>
    <p><small>serviceWorker.js</small></p>
        </section>
      </section>

      <!-- SECTION -->

      <section>

        <section>
          <h2>Handling Fetches</h2>
          <p>To handle fetches in our theoretical content-heavy site example:</p>
          <pre><code class="hljs">
  self.addEventListener('fetch', event => {
    // 1. Figure out if we should respond to this event at all
    //    (or let browser do it)
    // 2. If it's a request for content, take network-first strategy
    // 3. If it's a request for static assets, take cache-first strategy
  });
  </code></pre>
        </section>

        <section>
          <h3>Should We Respond to this Fetch?</h3>
          <p>Some questions we might want to consider when determining whether to handle a fetch:</p>
          <ul>
            <li class="fragment">Is the resource being requested served from the same origin?</li>
            <li class="fragment">Is the resource being requested something we ever want to cache?</li>
            <li class="fragment">What type of resource is being requested?</li>
            <li class="fragment">What is the HTTP method of this request? (hint: caching <em>DELETE</em> or <em>POST</em> requests might not be advisable)</li>
          </ul>
        </section>

        <section>
          <h3>event.request</h3>
          <p>The fetch handler is invoked for each resource request the browser makes. A <em>Request</em> object is available to the fetch handler as <em>event.request</em>. We can use it to answer some of our questions:</p>
          <pre><code class="hljs">
self.addEventListener('fetch', event => {
  // event.request is a reference to the Request object
  // representing the request for this resource
  var request = event.request;

  var requestMethod = request.method; // e.g. 'GET'
  var requestOrigin = new URL(request.url).origin;
  var acceptHeader = request.headers.get('Accept'); // MIME-type e.g.
});
</code></pre>
          <p><small>See also: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">MDN documentation on the <em>Request</em> interface</a>.</small></p>
        </section>

        <section>
          <h3>Identifying Requests for Content</h3>
        </section>

        <section>
          <h3>Implementing the Network Strategies</h3>
        </section>

        <section>
          <h3>Fetch-handling Code so Far...</h3>
        </section>

        <section>
          <h3>Handling Fetches: Some Things to Consider</h3>
        </section>

      </section>

      <!-- <section>
        <section>
          <h2>Managing Caches</h2>
        </section>

        <section>
          <h3>Pre-Caching Static Assets</h3>
        </section>

        <section>
          <h3>Read-Through Caching</h3>
        </section>

        <section>
          <h3>Retrieving from Cache</h3>
        </section>

        <section>
          <h3>Keeping Caches Tidy</h3>
        </section>

        <section>
          <h3>Keeping Caches From Being Huge</h3>
        </section>

      </section>

      <section>
        <section>
          <h2>Offline-First</h2>
        </section>

        <section>
          <h3>Pre-Caching</h3>
        </section>

        <section>
          <h3>Offline Fallback</h3>
        </section>

        <section>
          <h3>Offline Fallback Resources</h3>
        </section>

      </section> -->
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
